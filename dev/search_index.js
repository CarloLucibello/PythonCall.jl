var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#You-will-need","page":"Getting Started","title":"You will need","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.0 or higher.\nPython 3.5 or higher.","category":"page"},{"location":"getting-started/#Install-the-Julia-package","page":"Getting Started","title":"Install the Julia package","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\npkg\"add https://github.com/cjdoris/Python.jl\"","category":"page"},{"location":"getting-started/#Install-the-Python-package-(optional)","page":"Getting Started","title":"Install the Python package (optional)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This step is only required if you wish to call Julia from Python.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Currently the Python package is shipped with the source of the Julia package, and must be pip-installed manually. The following should work in most shells (including PowerShell):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pip install --upgrade $(julia -e \"using Python; print(Python.juliapypath)\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Note that this is a very small \"bootstrap\" package whose sole job is to locate and load Julia; the main functionality is in the main Julia package. Hence it is not necessary to upgrage the Python package every time you upgrade the Julia one.","category":"page"},{"location":"getting-started/#Environment-variables","page":"Getting Started","title":"Environment variables","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If Julia and Python are in your PATH, then no further set-up is required. Otherwise, the following environment variables control how the package finds these.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"PYTHONJL_EXE: Path to the Python executable. Or the special value CONDA which uses Python from the default conda environment, or CONDA:{env} to use the given environment.\nPYTHONJL_LIB: Path to the Python library. Normally this is inferred from the Python executable, but can be over-ridden.\nJULIAPY_EXE: Path to the Julia executable.\nJULIAPY_LIB: Path to the Julia library. Normally this is inferred from the Julia executable, but can be over-ridden.","category":"page"},{"location":"juliapy/#Julia-from-Python","page":"Julia from Python","title":"Julia from Python","text":"","category":"section"},{"location":"#Python.jl","page":"Home","title":"Python.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia couterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia 1.0 upwards and Python 3.5 upwards.","category":"page"},{"location":"pythonjl/#Python-from-Julia","page":"Python from Julia","title":"Python from Julia","text":"","category":"section"},{"location":"pythonjl/#Execute-Python-code","page":"Python from Julia","title":"Execute Python code","text":"","category":"section"},{"location":"pythonjl/#PyObjects","page":"Python from Julia","title":"PyObjects","text":"","category":"section"},{"location":"pythonjl/#Wrapper-types","page":"Python from Julia","title":"Wrapper types","text":"","category":"section"},{"location":"pythonjl/","page":"Python from Julia","title":"Python from Julia","text":"PyList\nPySet\nPyDict\nPyIterable\nPyArray\nPyBuffer\nPyIO\nPyPandasDataFrame","category":"page"},{"location":"pythonjl/#Python.PyList","page":"Python from Julia","title":"Python.PyList","text":"PyList{T=PyObject}([o])\n\nWrap the Python list o (or anything satisfying the sequence interface) as a Julia vector with elements of type T.\n\nIf o is not given, an empty list is created.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PySet","page":"Python from Julia","title":"Python.PySet","text":"PySet{T=PyObject}([o])\n\nWrap the Python set o (or anything satisfying the set interface) as a Julia set with elements of type T.\n\nIf o is not given, an empty set is created.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyDict","page":"Python from Julia","title":"Python.PyDict","text":"PyDict{K=PyObject, V=PyObject}([o])\n\nWrap the Python dictionary o (or anything satisfying the mapping interface) as a Julia dictionary with keys of type K and values of type V.\n\nIf o is not given, an empty dict is created.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyIterable","page":"Python from Julia","title":"Python.PyIterable","text":"PyIterable{T=PyObject}(o)\n\nWrap the Python object o into a Julia object which iterates values of type T.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyArray","page":"Python from Julia","title":"Python.PyArray","text":"PyArray{T,N,R,M,L}(o)\n\nInterpret the Python array o as a Julia array.\n\nThe input may be anything supporting the buffer protocol or the numpy array interface. This includes bytes, bytearray, array.array, numpy.ndarray, pandas.Series.\n\nAll type parameters are optional:\n\nT is the (Julia) element type.\nN is the number of dimensions.\nR is the type of elements of the underlying buffer (which may be different from T to allow some basic conversion).\nM is true if the array is mutable.\nL is true if the array supports fast linear indexing.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyBuffer","page":"Python from Julia","title":"Python.PyBuffer","text":"PyBuffer(o, [flags=C.PyBUF_FULL_RO])\n\nA reference to the underlying buffer of o, if it satisfies the buffer protocol.\n\nHas the following properties:\n\nbuf: Pointer to the data.\nobj: The exporting object (usually o).\nlen: The length of the buffer in bytes.\nreadonly: True if the buffer is immutable.\nitemsize: The size of each element.\nformat: The struct-syntax format of the element type.\nndim: The number of dimensions.\nshape: The length of the buffer in each dimension.\nstrides: The strides (in bytes) of the buffer in each dimension.\nsuboffsets: For indirect arrays. See the buffer protocol documentation.\nisccontiguous: True if the buffer is C-contiguous (e.g. numpy arrays).\nisfcontiguous: True if the buffer is Fortran-contiguous (e.g. Julia arrays).\neltype: The element type.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyIO","page":"Python from Julia","title":"Python.PyIO","text":"PyIO(o; own=false, text=missing, buflen=4096)\n\nWrap the Python byte-based IO stream o as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then o must be a binary stream and arbitrary binary I/O is possible. If text=true then o must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If o is a text stream and you really need a binary stream, then often PyIO(o.buffer) will work.\n\nFor efficiency, reads and writes are buffered before being sent to o. The size of the buffer is buflen.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyPandasDataFrame","page":"Python from Julia","title":"Python.PyPandasDataFrame","text":"PyPandasDataFrame(o; indexname=:index, columntypes=(), copy=false)\n\nWrap the Pandas dataframe o as a Julia table.\n\nThis object satisfies the Tables.jl and TableTraits.jl interfaces.\n\n:indexname is the name of the index column when converting this to a table, and may be nothing to exclude the index.\n:columntypes is an iterable of columnname=>type or [columnnames...]=>type pairs, used when converting to a table.\n:copy is true to copy columns on conversion.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Conversion-to-Python","page":"Python from Julia","title":"Conversion to Python","text":"","category":"section"},{"location":"pythonjl/#Conversion-from-Python","page":"Python from Julia","title":"Conversion from Python","text":"","category":"section"}]
}
