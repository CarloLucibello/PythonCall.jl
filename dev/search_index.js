var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#Install-the-Julia-package-PythonCall","page":"Getting Started","title":"Install the Julia package PythonCall","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"julia> using Pkg\n\npkg> add PythonCall","category":"page"},{"location":"getting-started/#Install-the-Python-package-juliacall-(optional)","page":"Getting Started","title":"Install the Python package juliacall (optional)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This step is only required if you wish to call Julia from Python.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Currently juliacall is shipped with the source of the Julia package, and must be pip-installed manually. The following should work in most shells (including PowerShell):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pip install $(julia -e \":PythonCall|>string|>Base.find_package|>dirname|>dirname|>print\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Alternatively you can just copy the package from the PythonCall source directory to somewhere in your PYTHONPATH.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Note that this is a very small \"bootstrap\" package whose sole job is to locate and load Julia; the main functionality is in the main Julia package. Hence it is not necessary to upgrage juliacall every time you upgrade PythonCall.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Note also that regardless of installing juliacall, a module called juliacall will always be loaded into the interpreter by PythonCall. This means that other Python packages can always import juliacall.","category":"page"},{"location":"getting-started/#Environment-variables","page":"Getting Started","title":"Environment variables","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"JULIA_PYTHONCALL_EXE: By default, PythonCall manages its own installation of Python specific to a particular Julia environment, so that the set of installed Python packages is isolated between environments. To instead use a pre-installed version of Python, set this variable to its path. It can simply be set to python if it is in your PATH.\nPYTHON_JULIACALL_EXE: The path to the Julia executable. By default, it uses julia.","category":"page"},{"location":"pythoncall/#The-Julia-module-PythonCall","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"","category":"section"},{"location":"pythoncall/#Py","page":"The Julia module PythonCall","title":"Py","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Py","category":"page"},{"location":"pythoncall/#PythonCall.Py","page":"The Julia module PythonCall","title":"PythonCall.Py","text":"Py(x)\n\nConvert x to a Python object.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"The object pybuiltins has all the standard Python builtin objects as its properties. Hence you can access pybuiltins.None and pybuiltins.TypeError.","category":"page"},{"location":"pythoncall/#@py","page":"The Julia module PythonCall","title":"@py","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"@py","category":"page"},{"location":"pythoncall/#PythonCall.@py","page":"The Julia module PythonCall","title":"PythonCall.@py","text":"@py expr\n\nEvaluate the given expression using Pythonic semantics.\n\nFor example:\n\nf(x, y) is translated to pycall(f, x, y)\nx + y is translated to pyadd(x, y)\nx === y is translated to pyis(x, y)\nx.foo is translated to pygetattr(x, \"foo\")\n\nCompound statements such as begin, if, while and for are supported.\n\nSee the online documentation for more details.\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#Python-functions","page":"The Julia module PythonCall","title":"Python functions","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Most of the functions in this section are essentially Python builtins with a py prefix. For example pyint(x) converts x to a Python int and is equivalent to int(x) in Python when x is a Python object.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"Notable exceptions are:","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert to convert a Python object to a Julia object.\npyimport to import a Python module.\npyjl to directly wrap a Julia object as a Python object.\npyclass to construct a new class.\npywith to emulate the Python with statement.","category":"page"},{"location":"pythoncall/#Construct-Python-objects","page":"The Julia module PythonCall","title":"Construct Python objects","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions convert Julia values into Python objects of standard types.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pybool\npyint\npyfloat\npycomplex\npystr\npybytes\npytuple\npylist\npycollist\npyrowlist\npyset\npyfrozenset\npydict\npyslice\npyrange\npymethod\npytype\npyclass","category":"page"},{"location":"pythoncall/#PythonCall.pybool","page":"The Julia module PythonCall","title":"PythonCall.pybool","text":"pybool(x)\n\nConvert x to a Python bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyint","page":"The Julia module PythonCall","title":"PythonCall.pyint","text":"pyint(x=0)\n\nConvert x to a Python int.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloat","page":"The Julia module PythonCall","title":"PythonCall.pyfloat","text":"pyfloat(x=0.0)\n\nConvert x to a Python float.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycomplex","page":"The Julia module PythonCall","title":"PythonCall.pycomplex","text":"pycomplex(x=0.0)\npycomplex(re, im)\n\nConvert x to a Python complex, or create one from given real and imaginary parts.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pystr","page":"The Julia module PythonCall","title":"PythonCall.pystr","text":"pystr(x)\n\nConvert x to a Python str.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybytes","page":"The Julia module PythonCall","title":"PythonCall.pybytes","text":"pybytes(x)\n\nConvert x to a Python bytes.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytuple","page":"The Julia module PythonCall","title":"PythonCall.pytuple","text":"pytuple(x=())\n\nConvert x to a Python tuple.\n\nIf x is a Python object, this is equivalent to tuple(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylist","page":"The Julia module PythonCall","title":"PythonCall.pylist","text":"pylist(x=())\n\nConvert x to a Python list.\n\nIf x is a Python object, this is equivalent to list(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycollist","page":"The Julia module PythonCall","title":"PythonCall.pycollist","text":"pycollist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of columns.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrowlist","page":"The Julia module PythonCall","title":"PythonCall.pyrowlist","text":"pyrowlist(x::AbstractArray)\n\nCreate a nested Python list-of-lists from the elements of x. For matrices, this is a list of rows.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyset","page":"The Julia module PythonCall","title":"PythonCall.pyset","text":"pyset(x=())\n\nConvert x to a Python set.\n\nIf x is a Python object, this is equivalent to set(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfrozenset","page":"The Julia module PythonCall","title":"PythonCall.pyfrozenset","text":"pyfrozenset(x=())\n\nConvert x to a Python frozenset.\n\nIf x is a Python object, this is equivalent to frozenset(x) in Python. Otherwise x must be iterable.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydict","page":"The Julia module PythonCall","title":"PythonCall.pydict","text":"pydict(x)\npydict(; x...)\n\nConvert x to a Python dict. In the second form, the keys are strings.\n\nIf x is a Python object, this is equivalent to dict(x) in Python. Otherwise x must iterate over key-value pairs.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyslice","page":"The Julia module PythonCall","title":"PythonCall.pyslice","text":"pyslice([[start], stop], [step])\n\nConstruct a Python slice. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrange","page":"The Julia module PythonCall","title":"PythonCall.pyrange","text":"pyrange([[start], [stop]], [step])\n\nConstruct a Python range. Unspecified arguments default to None.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymethod","page":"The Julia module PythonCall","title":"PythonCall.pymethod","text":"pymethod(x)\n\nConvert callable x to a Python instance method.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytype","page":"The Julia module PythonCall","title":"PythonCall.pytype","text":"pytype(x)\n\nThe Python type of x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyclass","page":"The Julia module PythonCall","title":"PythonCall.pyclass","text":"pyclass(name, bases=(); members...)\n\nConstruct a new Python type with the given name, bases and members.\n\nEquivalent to pytype(name, bases, members).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Wrap-Julia-values","page":"The Julia module PythonCall","title":"Wrap Julia values","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"These functions wrap Julia values into Python objects, documented here.","category":"page"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyjl\npyjlraw\npyisjl\npyjlvalue\npytextio\npybinaryio","category":"page"},{"location":"pythoncall/#PythonCall.pyjl","page":"The Julia module PythonCall","title":"PythonCall.pyjl","text":"pyjl([t], x)\n\nCreate a Python object wrapping the Julia object x.\n\nIf x is mutable, then mutating the returned object also mutates x, and vice versa.\n\nIts Python type is normally inferred from the type of x, but can be specified with t.\n\nFor example if x is an AbstractVector then the object will have type juliacall.VectorValue. This object will satisfy the Python sequence interface, so for example uses 0-up indexing.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlraw","page":"The Julia module PythonCall","title":"PythonCall.pyjlraw","text":"pyjlraw(v)\n\nCreate a Python object wrapping the Julia object x.\n\nIt has type juliacall.RawValue. This has a much more rigid \"Julian\" interface than pyjl(v). For example, accessing attributes or calling this object will always return a RawValue.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisjl","page":"The Julia module PythonCall","title":"PythonCall.pyisjl","text":"pyisjl(x)\n\nTest whether x is a wrapped Julia value, namely an instance of juliacall.ValueBase.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyjlvalue","page":"The Julia module PythonCall","title":"PythonCall.pyjlvalue","text":"pyjlvalue(x)\n\nExtract the value from the wrapped Julia value x.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytextio","page":"The Julia module PythonCall","title":"PythonCall.pytextio","text":"pytextio(io::IO)\n\nWrap io as a Python text IO object.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pybinaryio","page":"The Julia module PythonCall","title":"PythonCall.pybinaryio","text":"pybinaryio(io::IO)\n\nWrap io as a Python binary IO object.\n\nThis is the default behaviour of Py(io).\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Python-builtins","page":"The Julia module PythonCall","title":"Python builtins","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyconvert\n@pyconvert\npyimport\npyimport_conda\npywith\npyis\npyrepr\npyascii\npyhasattr\npygetattr\npysetattr\npydelattr\npydir\npycall\npylen\npycontains\npyin\npygetitem\npysetitem\npydelitem\npytruth\npyissubclass\npyisinstance\npyhash\npyiter","category":"page"},{"location":"pythoncall/#PythonCall.pyconvert","page":"The Julia module PythonCall","title":"PythonCall.pyconvert","text":"pyconvert(T, x, [d])\n\nConvert the Python object x to a T.\n\nIf d is specified, it is returned on failure instead of throwing an error.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.@pyconvert","page":"The Julia module PythonCall","title":"PythonCall.@pyconvert","text":"@pyconvert(T, x, [onfail])\n\nConvert the Python object x to a T.\n\nOn failure, evaluates to onfail, which defaults to return pyconvert_unconverted() (mainly useful for writing conversion rules).\n\n\n\n\n\n","category":"macro"},{"location":"pythoncall/#PythonCall.pyimport","page":"The Julia module PythonCall","title":"PythonCall.pyimport","text":"pyimport(m)\npyimport(m => k)\npyimport(m => (k1, k2, ...))\npyimport(m1, m2, ...)\n\nImport a module m, or an attribute k, or a tuple of attributes.\n\nIf several arguments are given, return the results of importing each one in a tuple.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pywith","page":"The Julia module PythonCall","title":"PythonCall.pywith","text":"pywith(f, o, d=nothing)\n\nEquivalent to with o as x: f(x) in Python, where x is a PyObject.\n\nOn success, the value of f(x) is returned.\n\nIf an exception occurs but is suppressed then d is returned.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyis","page":"The Julia module PythonCall","title":"PythonCall.pyis","text":"pyis(x, y)\n\nTrue if x and y are the same Python object. Equivalent to x is y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrepr","page":"The Julia module PythonCall","title":"PythonCall.pyrepr","text":"pyrepr(x)\n\nEquivalent to repr(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyascii","page":"The Julia module PythonCall","title":"PythonCall.pyascii","text":"pyascii(x)\n\nEquivalent to ascii(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhasattr","page":"The Julia module PythonCall","title":"PythonCall.pyhasattr","text":"pyhasattr(x, k)\n\nEquivalent to hasattr(x, k) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetattr","page":"The Julia module PythonCall","title":"PythonCall.pygetattr","text":"pygetattr(x, k)\n\nEquivalent to getattr(x, k) or x.k in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetattr","page":"The Julia module PythonCall","title":"PythonCall.pysetattr","text":"pysetattr(x, k, v)\n\nEquivalent to setattr(x, k, v) or x.k = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelattr","page":"The Julia module PythonCall","title":"PythonCall.pydelattr","text":"pydelattr(x, k)\n\nEquivalent to delattr(x, k) or del x.k in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydir","page":"The Julia module PythonCall","title":"PythonCall.pydir","text":"pydir(x)\n\nEquivalent to dir(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycall","page":"The Julia module PythonCall","title":"PythonCall.pycall","text":"pycall(f, args...; kwargs...)\n\nCall the Python object f with the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylen","page":"The Julia module PythonCall","title":"PythonCall.pylen","text":"pylen(x)\n\nThe length of x. Equivalent to len(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pycontains","page":"The Julia module PythonCall","title":"PythonCall.pycontains","text":"pycontains(x, v)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyin","page":"The Julia module PythonCall","title":"PythonCall.pyin","text":"pyin(v, x)\n\nEquivalent to v in x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygetitem","page":"The Julia module PythonCall","title":"PythonCall.pygetitem","text":"pygetitem(x, k)\n\nEquivalent to getitem(x, k) or x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysetitem","page":"The Julia module PythonCall","title":"PythonCall.pysetitem","text":"pysetitem(x, k, v)\n\nEquivalent to setitem(x, k, v) or x[k] = v in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydelitem","page":"The Julia module PythonCall","title":"PythonCall.pydelitem","text":"pydelitem(x, k)\n\nEquivalent to delitem(x, k) or del x[k] in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytruth","page":"The Julia module PythonCall","title":"PythonCall.pytruth","text":"pytruth(x)\n\nThe truthyness of x. Equivalent to bool(x) in Python, converted to a Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyissubclass","page":"The Julia module PythonCall","title":"PythonCall.pyissubclass","text":"pyissubclass(s, t)\n\nTest if s is a subclass of t. Equivalent to issubclass(s, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisinstance","page":"The Julia module PythonCall","title":"PythonCall.pyisinstance","text":"pyisinstance(x, t)\n\nTest if x is of type t. Equivalent to isinstance(x, t) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyhash","page":"The Julia module PythonCall","title":"PythonCall.pyhash","text":"pyhash(x)\n\nEquivalent to hash(x) in Python, converted to an Integer.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiter","page":"The Julia module PythonCall","title":"PythonCall.pyiter","text":"pyiter(x)\n\nEquivalent to iter(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Numeric-functions","page":"The Julia module PythonCall","title":"Numeric functions","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyneg\npypos\npyabs\npyinv\npyadd\npysub\npymul\npymatmul\npypow\npyfloordiv\npytruediv\npymod\npydivmod\npylshift\npyrshift\npyand\npyxor\npyor\npyiadd\npyisub\npyimul\npyimatmul\npyipow\npyifloordiv\npyitruediv\npyimod\npyilshift\npyirshift\npyiand\npyixor\npyior","category":"page"},{"location":"pythoncall/#PythonCall.pyneg","page":"The Julia module PythonCall","title":"PythonCall.pyneg","text":"pyneg(x)\n\nEquivalent to -x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypos","page":"The Julia module PythonCall","title":"PythonCall.pypos","text":"pypos(x)\n\nEquivalent to +x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyabs","page":"The Julia module PythonCall","title":"PythonCall.pyabs","text":"pyabs(x)\n\nEquivalent to abs(x) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyinv","page":"The Julia module PythonCall","title":"PythonCall.pyinv","text":"pyinv(x)\n\nEquivalent to ~x in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyadd","page":"The Julia module PythonCall","title":"PythonCall.pyadd","text":"pyadd(x, y)\n\nEquivalent to x + y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pysub","page":"The Julia module PythonCall","title":"PythonCall.pysub","text":"pysub(x, y)\n\nEquivalent to x - y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymul","page":"The Julia module PythonCall","title":"PythonCall.pymul","text":"pymul(x, y)\n\nEquivalent to x * y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymatmul","page":"The Julia module PythonCall","title":"PythonCall.pymatmul","text":"pymatmul(x, y)\n\nEquivalent to x @ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pypow","page":"The Julia module PythonCall","title":"PythonCall.pypow","text":"pypow(x, y, z=None)\n\nEquivalent to x ** y or pow(x, y, z) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyfloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyfloordiv","text":"pyfloordiv(x, y)\n\nEquivalent to x // y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pytruediv","page":"The Julia module PythonCall","title":"PythonCall.pytruediv","text":"pytruediv(x, y)\n\nEquivalent to x / y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pymod","page":"The Julia module PythonCall","title":"PythonCall.pymod","text":"pymod(x, y)\n\nEquivalent to x % y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pydivmod","page":"The Julia module PythonCall","title":"PythonCall.pydivmod","text":"pydivmod(x, y)\n\nEquivalent to divmod(x, y) in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylshift","page":"The Julia module PythonCall","title":"PythonCall.pylshift","text":"pylshift(x, y)\n\nEquivalent to x << y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyrshift","page":"The Julia module PythonCall","title":"PythonCall.pyrshift","text":"pyrshift(x, y)\n\nEquivalent to x >> y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyand","page":"The Julia module PythonCall","title":"PythonCall.pyand","text":"pyand(x, y)\n\nEquivalent to x & y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyxor","page":"The Julia module PythonCall","title":"PythonCall.pyxor","text":"pyxor(x, y)\n\nEquivalent to x ^ y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyor","page":"The Julia module PythonCall","title":"PythonCall.pyor","text":"pyor(x, y)\n\nEquivalent to x | y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiadd","page":"The Julia module PythonCall","title":"PythonCall.pyiadd","text":"pyiadd(x, y)\n\nIn-place add. x = pyiadd(x, y) is equivalent to x += y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyisub","page":"The Julia module PythonCall","title":"PythonCall.pyisub","text":"pyisub(x, y)\n\nIn-place subtract. x = pyisub(x, y) is equivalent to x -= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimul","page":"The Julia module PythonCall","title":"PythonCall.pyimul","text":"pyimul(x, y)\n\nIn-place multiply. x = pyimul(x, y) is equivalent to x *= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimatmul","page":"The Julia module PythonCall","title":"PythonCall.pyimatmul","text":"pyimatmul(x, y)\n\nIn-place matrix multiply. x = pyimatmul(x, y) is equivalent to x @= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyipow","page":"The Julia module PythonCall","title":"PythonCall.pyipow","text":"pyipow(x, y, z=None)\n\nIn-place power. x = pyipow(x, y) is equivalent to x **= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyifloordiv","page":"The Julia module PythonCall","title":"PythonCall.pyifloordiv","text":"pyifloordiv(x, y)\n\nIn-place floor divide. x = pyifloordiv(x, y) is equivalent to x //= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyitruediv","page":"The Julia module PythonCall","title":"PythonCall.pyitruediv","text":"pyitruediv(x, y)\n\nIn-place true division. x = pyitruediv(x, y) is equivalent to x /= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyimod","page":"The Julia module PythonCall","title":"PythonCall.pyimod","text":"pyimod(x, y)\n\nIn-place subtraction. x = pyimod(x, y) is equivalent to x %= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyilshift","page":"The Julia module PythonCall","title":"PythonCall.pyilshift","text":"pyilshift(x, y)\n\nIn-place left shift. x = pyilshift(x, y) is equivalent to x <<= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyirshift","page":"The Julia module PythonCall","title":"PythonCall.pyirshift","text":"pyirshift(x, y)\n\nIn-place right shift. x = pyirshift(x, y) is equivalent to x >>= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyiand","page":"The Julia module PythonCall","title":"PythonCall.pyiand","text":"pyiand(x, y)\n\nIn-place and. x = pyiand(x, y) is equivalent to x &= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyixor","page":"The Julia module PythonCall","title":"PythonCall.pyixor","text":"pyixor(x, y)\n\nIn-place xor. x = pyixor(x, y) is equivalent to x ^= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyior","page":"The Julia module PythonCall","title":"PythonCall.pyior","text":"pyior(x, y)\n\nIn-place or. x = pyior(x, y) is equivalent to x |= y in Python.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#Comparisons","page":"The Julia module PythonCall","title":"Comparisons","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"pyeq\npyne\npyle\npylt\npyge\npygt","category":"page"},{"location":"pythoncall/#PythonCall.pyeq","page":"The Julia module PythonCall","title":"PythonCall.pyeq","text":"pyeq(x, y)\npyeq(Bool, x, y)\n\nEquivalent to x == y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyne","page":"The Julia module PythonCall","title":"PythonCall.pyne","text":"pyne(x, y)\npyne(Bool, x, y)\n\nEquivalent to x != y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyle","page":"The Julia module PythonCall","title":"PythonCall.pyle","text":"pyle(x, y)\npyle(Bool, x, y)\n\nEquivalent to x <= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pylt","page":"The Julia module PythonCall","title":"PythonCall.pylt","text":"pylt(x, y)\npylt(Bool, x, y)\n\nEquivalent to x < y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pyge","page":"The Julia module PythonCall","title":"PythonCall.pyge","text":"pyge(x, y)\npyge(Bool, x, y)\n\nEquivalent to x >= y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#PythonCall.pygt","page":"The Julia module PythonCall","title":"PythonCall.pygt","text":"pygt(x, y)\npygt(Bool, x, y)\n\nEquivalent to x > y in Python. The second form converts to Bool.\n\n\n\n\n\n","category":"function"},{"location":"pythoncall/#python-wrappers","page":"The Julia module PythonCall","title":"Wrapper types","text":"","category":"section"},{"location":"pythoncall/","page":"The Julia module PythonCall","title":"The Julia module PythonCall","text":"PyList\nPySet\nPyDict\nPyIterable\nPyArray\nPyIO\nPyTable\nPyPandasDataFrame\nPyObjectArray","category":"page"},{"location":"pythoncall/#PythonCall.PyList","page":"The Julia module PythonCall","title":"PythonCall.PyList","text":"PyList{T=Py}([x])\n\nWraps the Python list x (or anything satisfying the sequence interface) as an AbstractVector{T}.\n\nIf x is not a Python object, it is converted to one using pylist.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PySet","page":"The Julia module PythonCall","title":"PythonCall.PySet","text":"PySet{T=Py}([x])\n\nWraps the Python set x (or anything satisfying the set interface) as an AbstractSet{T}.\n\nIf x is not a Python object, it is converted to one using pyset.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyDict","page":"The Julia module PythonCall","title":"PythonCall.PyDict","text":"PyDict{K=Py,V=Py}([x])\n\nWraps the Python dict x (or anything satisfying the mapping interface) as an AbstractDict{K,V}.\n\nIf x is not a Python object, it is converted to one using pydict.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyIterable","page":"The Julia module PythonCall","title":"PythonCall.PyIterable","text":"PyIterable{T=Py}(x)\n\nThis object iterates over iterable Python object x, yielding values of type T.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyArray","page":"The Julia module PythonCall","title":"PythonCall.PyArray","text":"PyArray{T,N,M,L,R}(x; copy=true, array=true, buffer=true)\n\nWrap the Python array x as a Julia AbstractArray{T,N}.\n\nThe input x can be bytes, bytearray, array.array, numpy.ndarray or anything satisfying the buffer protocol (if buffer=true) or the numpy array interface (if array=true).\n\nIf copy=false then the resulting array is guaranteed to directly wrap the data in x. If copy=true then a copy is taken if necessary to produce an array.\n\nThe type parameters are all optional, and are:\n\nT: The element type.\nN: The number of dimensions.\nM: True if the array is mutable.\nL: True if the array supports fast linear indexing.\nR: The element type of the underlying buffer. Equal to T for scalar numeric types.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyIO","page":"The Julia module PythonCall","title":"PythonCall.PyIO","text":"PyIO(x; own=false, text=missing, buflen=4096)\n\nWrap the Python IO stream x as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then x must be a binary stream and arbitrary binary I/O is possible. If text=true then x must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If x is a text stream and you really need a binary stream, then often PyIO(x.buffer) will work.\n\nFor efficiency, reads and writes are buffered before being sent to x. The size of the buffers is buflen. The buffers are cleared using flush.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyTable","page":"The Julia module PythonCall","title":"PythonCall.PyTable","text":"PyTable\n\nAbstract type for Python wrappers which may be interpretable as Tables.jl-compatible tables.\n\nIf pyconvert(PyTable, x::Py) is a table, then x is also a table.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyPandasDataFrame","page":"The Julia module PythonCall","title":"PythonCall.PyPandasDataFrame","text":"PyPandasDataFrame(x; indexname=nothing, columntypes=Dict())\n\nWraps the pandas DataFrame x as a Tables.jl-compatible table.\n\nindexname is the name of the column to contain the index. It may be nothing to exclude the index.\n\ncolumntypes is a mapping of column names to column element types, in case automatic deduction does not work.\n\n\n\n\n\n","category":"type"},{"location":"pythoncall/#PythonCall.PyObjectArray","page":"The Julia module PythonCall","title":"PythonCall.PyObjectArray","text":"PyObjectArray(undef, dims...)\nPyObjectArray(array)\n\nAn array of Pys which supports the Python buffer protocol.\n\nInternally, the objects are stored as an array of pointers.\n\n\n\n\n\n","category":"type"},{"location":"conversion/#Conversion-Rules","page":"Conversion Rules","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"This page documents the rules used to convert values between Julia and Python.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"In both directions, the default behaviour is to allow conversion between immutable values. Mutable values will be \"wrapped\" so that mutations on the wrapper affect the original object.","category":"page"},{"location":"conversion/#jl2py","page":"Conversion Rules","title":"Julia to Python","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"When a Julia object is converted to a Python one (e.g. by calling PyObject, by interpolating it into a @py command, or passing it as an argument to a Python function) the following rules are used by default.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The user can always explicitly choose a different conversion (e.g. by calling pylist or pydict).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From To\nAny Python object type (PyObject, PyList, etc.) itself\nNothing, Missing None\nBool bool\nStandard integer (IntXX, UIntXX, BigInt) int\nStandard rational (Rational{T}, T a standard integer) fractions.Fraction\nStandard float (FloatXX) float\nStandard complex (Complex{T}, T a standard float) complex\nStandard string/char (String and SubString{String}, Char) str\nTuple tuple\nStandard integer range (AbstractRange{T}, T a standard integer) range\nDate, Time, DateTime (from Dates) date, time, datetime (from datetime)\nSecond, Millisecond, Microsecond, Nanosecond (from Dates) timedelta (from datetime)\nNumber juliacall.NumberValue, juliacall.ComplexValue, etc.\nAbstractArray juliacall.ArrayValue, juliacall.VectorValue\nAbstractDict juliacall.DictValue\nAbstractSet juliacall.SetValue\nIO juliacall.BufferedIOValue\nModule juliacall.ModuleValue\nType juliacall.TypeValue\nAnything else juliacall.AnyValue","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The juliacall.*Value types are all subtypes of juliacall.AnyValue. They wrap a Julia value, providing access to Julia semantics: it can be called, indexed, and so on. Subtypes add additional Pythonic semantics. Read more here.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"This conversion policy is defined/implemented by PythonCall.C.PyObject_From and PythonCall.C.PyJuliaValue_From. Package authors can (carefully) overload these with additional rules for custom types.","category":"page"},{"location":"conversion/#py2jl","page":"Conversion Rules","title":"Python to Julia","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From Julia, one can convert Python objects to a desired type using pyconvert(T, x) for example, or @pyv `...`::T.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From Python, when a value is passed to Julia, it is typically converted to a corresponding Julia value using pyconvert(Any, x).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"Quite general conversions are allowed, and the target type T can be as specific as you like. For example","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"@pyv `[1, None, 3]`::Tuple{Vararg{Union{AbstractFloat,Missing}}}","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"evaluates to (1.0, missing, 2.0).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The following table specifies the conversion rules in place. If the initial Python type matches the \"From\" column and the desired type T intersects with the \"To\" column, then that conversion is attempted. Conversions are tried in priority order, then in specificity order.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From To\nTop priority (wrapped values). \njuliacall.AnyValue Any\nVery high priority (arrays). \nObjects satisfying the buffer or array interface (inc. bytes, bytearray, array.array, numpy.ndarray) PyArray\nHigh priority (canonical conversions). \nNone Nothing\nbool Bool\nnumbers.Integral (inc. int) Integer (prefers Int, or BigInt on overflow)\nfloat Float64\ncomplex Complex{Float64}\nrange StepRange\nstr String\ntuple Tuple\ncollections.abc.Mapping (inc. dict) PyDict\ncollections.abc.Sequence (inc. list) PyList\ncollections.abc.Set (inc. set, frozenset) PySet\nio.IOBase (includes open files) PyIO\ndatetime.date/datetime.time/datetime.datetime Date/Time/DateTime\ndatetime.timedelta Microsecond (or Millisecond or Second on overflow)\nnumpy.intXX/numpy.uintXX/numpy.floatXX IntXX/UIntXX/FloatXX\nStandard priority (other reasonable conversions). \nNone Missing\nbytes Vector{UInt8}, Vector{Int8}, String\nstr String, Symbol, Char, Vector{UInt8}, Vector{Int8}\nrange UnitRange\ncollections.abc.Mapping Dict\ncollections.abc.Iterable Vector, Set, Tuple, NamedTuple, Pair\ndatetime.timedelta Dates.CompoundPeriod\nnumbers.Integral Integer, Rational, Real, Number\nnumbers.Real AbstractFloat, Number, Missing/Nothing (if NaN)\nnumbers.Complex Complex, Number\nctypes.c_int and other integers Integer, Rational, Real, Number\nctypes.c_float/ctypes.c_double Cfloat/Cdouble, AbstractFloat, Real, Number\nctypes.c_voidp Ptr{Cvoid}, Ptr\nctypes.c_char_p Cstring, Ptr{Cchar}, Ptr\nctypes.c_wchar_p Cwstring, Ptr{Cwchar}, Ptr\nnumpy.intXX/numpy.uintXX/numpy.floatXX Integer, Rational, Real, Number\nObjects satisfying the buffer or array interface Array\nLow priority (fallback to PyObject). \nAnything PyObject\nBottom priority (must be explicitly specified by excluding PyObject). \nObjects satisfying the buffer interface PyBuffer\nAnything PyRef","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"Package authors can (carefully) add extra rules by calling PythonCall.C.PyObject_TryConvert_AddRule in __init__.","category":"page"},{"location":"juliacall/#The-Python-module-juliacall","page":"The Python module juliacall","title":"The Python module juliacall","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"For interactive or scripting use, the simplest way to get started is:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"from juliacall import Main as jl","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"This loads a single variable jl (a ModuleValue) which represents the Main module in Julia, from which all of Julia's functionality is available.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"If you are writing a package which uses Julia, then to avoid polluting the global Main namespace you should do:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"import juliacall; jl = juliacall.newmodule(\"SomeName\");","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Now you can do jl.rand(jl.Bool, 5, 5), which is equivalent to rand(Bool, 5, 5) in Julia.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When a Python value is passed to Julia, then typically it will be converted according to this table with T=Any. Sometimes a more specific type will be used, such as when assigning to an array whose element type is known.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"When a Julia value is returned to Python, it will normally be converted according to this table.","category":"page"},{"location":"juliacall/#julia-wrappers","page":"The Python module juliacall","title":"Wrapper types","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"Apart from a few fundamental immutable types (see here), all Julia values are by default converted into Python to some AnyValue object, which wraps the original value. Some types are converted to a subclass of AnyValue which provides additional Python semantics –- e.g. Julia vectors are interpreted as Python sequences.","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"There is also a RawValue object, which gives a stricter \"Julia-only\" interface, documented below. These types all inherit from ValueBase:","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"ValueBase\nRawValue\nAnyValue\nNumberValue\nComplexValue\nRealValue\nRationalValue\nIntegerValue\nArrayValue\nVectorValue\nDictValue\nSetValue\nIOValue\nBinaryIOValue\nTextIOValue\nModuleValue\nTypeValue","category":"page"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.AnyValue - Class\n\nWraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), iteration, comparisons, `len(x)`, `a in x`, `dir(x)`.\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to [this table](@ref jl2py). This is typically a builtin Python type (for immutables) or a subtype of `AnyValue`.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, `_b` at the end of an attribute is replaced with `!` and `_bb` is replaced with `!!`.\n\n###### Members\n- `_jl_raw()`: Convert to a [`RawValue`](#juliacall.RawValue). (See also [`pyjlraw`](@ref).)\n- `_jl_display()`: Display the object using Julia's display mechanism.\n- `_jl_help()`: Display help for the object.","category":"page"},{"location":"juliacall/#juliacall.AnyValue","page":"The Python module juliacall","title":"juliacall.AnyValue","text":"Wraps any Julia object, giving it some basic Python semantics. Subtypes provide extra semantics.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), iteration, comparisons, len(x), a in x, dir(x).\n\nCalling, indexing, attribute access, etc. will convert the result to a Python object according to this table. This is typically a builtin Python type (for immutables) or a subtype of AnyValue.\n\nAttribute access can be used to access Julia properties as well as normal class members. In the case of a name clash, the class member will take precedence. For convenience with Julia naming conventions, _b at the end of an attribute is replaced with ! and _bb is replaced with !!.\n\nMembers\n\n_jl_raw(): Convert to a RawValue. (See also pyjlraw.)\n_jl_display(): Display the object using Julia's display mechanism.\n_jl_help(): Display help for the object.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.NumberValue - Class\n\nThis wraps any Julia `Number` value. It is a subclass of `numbers.Number` and behaves similar to other Python numbers.\n\nThere are also subtypes `ComplexValue`, `RealValue`, `RationalValue`, `IntegerValue` which wrap values of the corresponding Julia types, and are subclasses of the corresponding `numbers` ABC.","category":"page"},{"location":"juliacall/#juliacall.NumberValue","page":"The Python module juliacall","title":"juliacall.NumberValue","text":"This wraps any Julia Number value. It is a subclass of numbers.Number and behaves similar to other Python numbers.\n\nThere are also subtypes ComplexValue, RealValue, RationalValue, IntegerValue which wrap values of the corresponding Julia types, and are subclasses of the corresponding numbers ABC.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.ArrayValue - Class\n\nThis wraps any Julia `AbstractArray` value. It is a subclass of `collections.abc.Collection`.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype `VectorValue` which wraps any `AbstractVector`. It is a subclass of `collections.abc.Sequence` and behaves similar to a Python `list`.\n\nIf the array is strided and its eltype is supported (i.e. `Bool`, `IntXX`, `UIntXX`, `FloatXX`, `Complex{FloatXX}`, `Ptr{Cvoid}` or `Tuple` or `NamedTuple` of these) then it supports the buffer protocol and the numpy array interface. This means that `numpy.asarray(this)` will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy `__array__` method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, `numpy.asarray(this)` is a copy of the original array.\n\n###### Members\n- `ndim`: The number of dimensions.\n- `shape`: Tuple of lengths in each dimension.\n- `copy()`: A copy of the array.\n- `reshape(shape)`: A reshaped view of the array.","category":"page"},{"location":"juliacall/#juliacall.ArrayValue","page":"The Python module juliacall","title":"juliacall.ArrayValue","text":"This wraps any Julia AbstractArray value. It is a subclass of collections.abc.Collection.\n\nIt supports zero-up indexing, and can be indexed with integers or slices. Slicing returns a view of the original array.\n\nThere is also the subtype VectorValue which wraps any AbstractVector. It is a subclass of collections.abc.Sequence and behaves similar to a Python list.\n\nIf the array is strided and its eltype is supported (i.e. Bool, IntXX, UIntXX, FloatXX, Complex{FloatXX}, Ptr{Cvoid} or Tuple or NamedTuple of these) then it supports the buffer protocol and the numpy array interface. This means that numpy.asarray(this) will yield a view of the original array, so mutations are visible on the original.\n\nOtherwise, the numpy __array__ method is supported, and this returns an array of Python objects converted from the contents of the array. In this case, numpy.asarray(this) is a copy of the original array.\n\nMembers\n\nndim: The number of dimensions.\nshape: Tuple of lengths in each dimension.\ncopy(): A copy of the array.\nreshape(shape): A reshaped view of the array.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.DictValue - Class\nThis wraps any Julia `AbstractDict` value. It is a subclass of `collections.abc.Mapping` and behaves similar to a Python `dict`.","category":"page"},{"location":"juliacall/#juliacall.DictValue","page":"The Python module juliacall","title":"juliacall.DictValue","text":"This wraps any Julia AbstractDict value. It is a subclass of collections.abc.Mapping and behaves similar to a Python dict.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.SetValue - Class\nThis wraps any Julia `AbstractSet` value. It is a subclass of `collections.abc.Set` and behaves similar to a Python `set`.","category":"page"},{"location":"juliacall/#juliacall.SetValue","page":"The Python module juliacall","title":"juliacall.SetValue","text":"This wraps any Julia AbstractSet value. It is a subclass of collections.abc.Set and behaves similar to a Python set.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.IOValue - Class\n\nThis wraps any Julia `IO` value. It is a subclass of `io.IOBase` and behaves like Python files.\n\nThere are also subtypes `BinaryIOValue` and `TextIOValue`, which are subclasses of `io.BufferedIOBase` (buffered bytes) and `io.TextIOBase` (text).","category":"page"},{"location":"juliacall/#juliacall.IOValue","page":"The Python module juliacall","title":"juliacall.IOValue","text":"This wraps any Julia IO value. It is a subclass of io.IOBase and behaves like Python files.\n\nThere are also subtypes BinaryIOValue and TextIOValue, which are subclasses of io.BufferedIOBase (buffered bytes) and io.TextIOBase (text).\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.ModuleValue - Class\nThis wraps any Julia `Module` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except for one additional convenience method:\n- `seval([module=self], code)`: Evaluates the given code (a string) in the given module.","category":"page"},{"location":"juliacall/#juliacall.ModuleValue","page":"The Python module juliacall","title":"juliacall.ModuleValue","text":"This wraps any Julia Module value.\n\nIt is the same as AnyValue except for one additional convenience method:\n\nseval([module=self], code): Evaluates the given code (a string) in the given module.\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.TypeValue - Class\n\nThis wraps any Julia `Type` value.\n\nIt is the same as [`AnyValue`](#juliacall.AnyValue) except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\n```python\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n```","category":"page"},{"location":"juliacall/#juliacall.TypeValue","page":"The Python module juliacall","title":"juliacall.TypeValue","text":"This wraps any Julia Type value.\n\nIt is the same as AnyValue except that indexing is used to access Julia's \"curly\" syntax for specifying parametric types:\n\nfrom juliacall import Main as jl\n# equivalent to Vector{Int}() in Julia\njl.Vector[jl.Int]()\n\n","category":"class"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.RawValue - Class\n\nWraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports `repr(x)`, `str(x)`, attributes (`x.attr`), calling (`x(a,b)`), `len(x)`, `dir(x)`.\n\nThis is very similar to [`AnyValue`](#juliacall.AnyValue) except that indexing, calling, etc. will always return a `RawValue`.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\n###### Members\n- `_jl_any()`: Convert to a [`AnyValue`](#juliacall.AnyValue) (or subclass). (See also [`pyjl`](@ref).)","category":"page"},{"location":"juliacall/#juliacall.RawValue","page":"The Python module juliacall","title":"juliacall.RawValue","text":"Wraps any Julia value with a rigid interface suitable for generic programming.\n\nSupports repr(x), str(x), attributes (x.attr), calling (x(a,b)), len(x), dir(x).\n\nThis is very similar to AnyValue except that indexing, calling, etc. will always return a RawValue.\n\nIndexing with a tuple corresponds to indexing in Julia with multiple values. To index with a single tuple, it will need to be wrapped in another tuple.\n\nMembers\n\n_jl_any(): Convert to a AnyValue (or subclass). (See also pyjl.)\n\n","category":"class"},{"location":"juliacall/#Utilities","page":"The Python module juliacall","title":"Utilities","text":"","category":"section"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.newmodule - Function\n\n```python\nnewmodule(name)\n```\n\nA new module with the given name.","category":"page"},{"location":"juliacall/#juliacall.newmodule","page":"The Python module juliacall","title":"juliacall.newmodule","text":"newmodule(name)\n\nA new module with the given name.\n\n","category":"function"},{"location":"juliacall/","page":"The Python module juliacall","title":"The Python module juliacall","text":"juliacall.As - Class\n\n```python\nAs(x, T)\n```\n\nWhen passed as an argument to a Julia function, is interpreted as `x` converted to Julia type `T`.","category":"page"},{"location":"juliacall/#juliacall.As","page":"The Python module juliacall","title":"juliacall.As","text":"As(x, T)\n\nWhen passed as an argument to a Julia function, is interpreted as x converted to Julia type T.\n\n","category":"class"},{"location":"compat/#Compatibility-Tools","page":"Compatibility Tools","title":"Compatibility Tools","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some packages require a little extra help to work nicely with PythonCall.jl.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Some of these are \"fixes\" that are silently applied for you, and some are just extra functions to bridge a gap. We aim to keep these as minimal as possible.","category":"page"},{"location":"compat/#Stdlib","page":"Compatibility Tools","title":"Stdlib","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Whenever a Python exception is displayed by Julia, sys.last_traceback and friends are set. This allows the post-mortem debugger pdb.pm() to work. Disable by setting PythonCall.CONFIG.auto_sys_last_traceback = false.","category":"page"},{"location":"compat/#Tabular-data-and-Pandas","page":"Compatibility Tools","title":"Tabular data & Pandas","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"A pandas.DataFrame can be wrapped in Julia as a PyPandasDataFrame, providing a Tables.jl-compatible interface.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Furthermore, any Python object which can be converted to a PyTable (e.g. pandas.DataFrame can be converted to PyPandasDataFrame) satisfies the Tables.jl interface.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"In the other direction, the following functions can be used to convert any Tables.jl-compatible table to a Python table.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"pytable","category":"page"},{"location":"compat/#PythonCall.pytable","page":"Compatibility Tools","title":"PythonCall.pytable","text":"pytable(src, format=:pandas; ...)\n\nConstruct a Python table from the Tables.jl-compatible table src.\n\nThe format controls the type of the resulting table, and is one of:\n\n:pandas: A pandas.DataFrame. Keyword arguments are passed to the DataFrame constructor.\n:columns: A dict mapping column names to columns.\n:rows: A list of rows, which are namedtuples.\n:rowdicts: A list of rows, which are dicts.\n\n\n\n\n\n","category":"function"},{"location":"compat/#MatPlotLib-/-PyPlot","page":"Compatibility Tools","title":"MatPlotLib / PyPlot","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"pyplot_show","category":"page"},{"location":"compat/#PythonCall.pyplot_show","page":"Compatibility Tools","title":"PythonCall.pyplot_show","text":"pyplot_show([fig]; close=true, [format])\n\nShow the matplotlib/pyplot/seaborn/etc figure fig, or all open figures if not given, using Julia's display mechanism.\n\nIf close is true, the figure is also closed.\n\nThe format specifies the file format of the generated image. By default this is pyplot.rcParams[\"savefig.format\"] or \"png\". It can be one of \"png\", \"jpg\", \"jpeg\", \"tif\", \"tiff\", \"svg\" or \"pdf\".\n\n\n\n\n\n","category":"function"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If Julia is running an IJulia kernel, pyplot_show() is automatically called after executing a cell, so that plots generated in a cell are always shown (similar to IPython). It can be disabled by setting PythonCall.CONFIG.auto_pyplot_show = false.","category":"page"},{"location":"compat/#GUIs-(including-MatPlotLib)","page":"Compatibility Tools","title":"GUIs (including MatPlotLib)","text":"","category":"section"},{"location":"compat/#Event-loops","page":"Compatibility Tools","title":"Event loops","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If for example you wish to use PyPlot in interactive mode (matplotlib.pyplot.ion()) then activating the correct event loop will allow it to work.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"PythonCall.event_loop_on\nPythonCall.event_loop_off","category":"page"},{"location":"compat/#PythonCall.event_loop_on","page":"Compatibility Tools","title":"PythonCall.event_loop_on","text":"event_loop_on(g::Symbol; interval=0.04, fix=false)\n\nActivate an event loop for the GUI framework g, so that the framework can run in the background of a Julia session.\n\nThe event loop runs every interval seconds. If fix is true and g is a Qt framework, then fix_qt_plugin_path is called.\n\nSupported values of g (and the Python module they relate to) are: :pyqt4 (PyQt4), :pyqt5 (PyQt5), :pyside (PySide), :pyside2 (PySide2), :gtk (gtk), :gtk3 (gi), :wx (wx), :tkinter (tkinter).\n\n\n\n\n\n","category":"function"},{"location":"compat/#PythonCall.event_loop_off","page":"Compatibility Tools","title":"PythonCall.event_loop_off","text":"event_loop_off(g::Symbol)\n\nTerminate the event loop g if it is running.\n\n\n\n\n\n","category":"function"},{"location":"compat/#Qt-path-fix","page":"Compatibility Tools","title":"Qt path fix","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"PythonCall.fix_qt_plugin_path","category":"page"},{"location":"compat/#PythonCall.fix_qt_plugin_path","page":"Compatibility Tools","title":"PythonCall.fix_qt_plugin_path","text":"fix_qt_plugin_path()\n\nTry to set the QT_PLUGIN_PATH environment variable in Python, if not already set.\n\nThis fixes the problem that Qt does not know where to find its qt.conf file, because it always looks relative to sys.executable, which can be the Julia executable not the Python one when using this package.\n\nIf CONFIG.auto_fix_qt_plugin_path is true, then this is run automatically before PyQt4, PyQt5, PySide or PySide2 are imported.\n\n\n\n\n\n","category":"function"},{"location":"compat/#IPython","page":"Compatibility Tools","title":"IPython","text":"","category":"section"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"If Python is running an IPython kernel, then:","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"Julia's Base.stdout is set to Python's sys.stdout.\nAn IPythonDisplay is pushed onto Julia's display stack, so that display(x) goes to IPython if possible.","category":"page"},{"location":"compat/","page":"Compatibility Tools","title":"Compatibility Tools","text":"This is disabled by setting PythonCall.CONFIG.auto_ipython_display = false.","category":"page"},{"location":"#PythonCall.jl","page":"Home","title":"PythonCall.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python® and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia couterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia 1.0 upwards and Python 3.5 upwards.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is actually two modules working together: a Julia one called PythonCall and a tiny Python one called juliacall.","category":"page"},{"location":"pycall/#Comparison-to-PyCall","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"","category":"section"},{"location":"pycall/","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"The existing package PyCall is another similar interface to Python.","category":"page"},{"location":"pycall/","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"You can use both PythonCall and PyCall in the same session, provided they are both using the same Python library. One way to ensure this is to set JULIA_PYTHONCALL_EXE=PYCALL (see Environment variables).","category":"page"},{"location":"pycall/","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"Here is a comparison of the designs:","category":"page"},{"location":"pycall/","page":"Comparison to PyCall","title":"Comparison to PyCall","text":"Flexibility of conversion. The mechanisms for data conversion from Python to Julia are different. In PyCall, conversion to T (via convert(T,::PyObject)) essentially only takes T into account, so for example when T=Real then the input will always be converted to a Python float, which is then converted to a Cdouble. In PythonCall, conversion takes into account both the target type T and the Python type of the Python object, and an extensible system allows one to declare conversions for any combination. Many conversions for overlapping combinations can be defined and the most specific one takes precedence. Hence in PythonCall, converting to a Real might return an Int (e.g. the input is a int), or Cdouble (e.g. the input is float), or Rational{BigInt}, or...\nLossiness of conversion from Python. In PyCall, the default PyAny conversion from Python to Julia can be lossy in the sense that it is impossible to recover the original value exactly. For example a list of ints is converted to a Vector{Int} which is a copy of the data, and therefore modifying the original list is not possible. It is also a source of off-by-one errors, since Vector and list have different indexing semantics. In PythonCall, the default conversion is to PyObject (non-lossy), and even if you convert to Any then by default this will be non-lossy: for example a list will be converted to a PyList which is a Vector-like view of the list.\nLossiness of conversion to Python. Similarly, in PyCall the default conversion from Julia to Python can be lossy: a Vector{Int} will be converted to a list of ints for example, losing mutability of the original vector. In PythonCall, only immutable values are truly converted to Python, everything else is wrapped into a Python wrapper around the Julia value: a Vector{Int} is wrapped into a juliacall.VectorValue which is a list-like sequence type\nAutomatic conversion. In PyCall, most function calls, attribute accesses, indexing, etc. of Python objects by default automatically convert their result to a Julia type. In PythonCall the default is to always return PyObject. The latter behaviour provides type-stability. It also makes interacting with Python values more predictable and allows generic programming (where the type of the result is not known). It also allows the user to pick another type to convert to after the fact, whereas since PyCall conversion can be lossy, this is sometimes not possible there.\nBuilding. PyCall locates libpython in its build step, so that it is a const in the module code. This makes ccalls and the like straightforward. PythonCall does this at run-time, which slightly complicates the code (although it is abstracted away) but means that the module does not need to be rebulit for different Python versions.\nDefault Python. By default PyCall uses the version of Python in conda and will silently install miniconda for you if it doesn't exist. PythonCall by default simply uses the version of Python in the PATH. Both are customizable through environment variables.\nPython modules. PyCall has a companion Python module julia for calling Julia from Python. So does PythonCall, but called juliacall. Both of them use PyCall/PythonCall under the hood on the Julia side. The PyCall one is itself about as complex in implementation as PyCall. The PythonCall one is about 50 lines of code (essentially just finding and loading libjulia and the PythonCall module) and provides a single simple entrypoint: the julia Main module.\nCompatability. PyCall supports Julia 0.7+ and Python 2.7+, whereas PythonCall supports Julia 1.0+ and Python 3.5+. PyCall requires numpy to be installed, PythonCall doesn't (it provides the same fast array access through the buffer protocol and array interface).\nStartup time. PythonCall takes longer to start than PyCall, largely because there are a lot of wrapper types (juliacall.AnyValue etc.) to compile.","category":"page"}]
}
