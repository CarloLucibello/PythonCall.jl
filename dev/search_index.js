var documenterSearchIndex = {"docs":
[{"location":"getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting-started/#You-will-need","page":"Getting Started","title":"You will need","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Julia 1.0 or higher.\nPython 3.5 or higher.","category":"page"},{"location":"getting-started/#Install-the-Julia-package","page":"Getting Started","title":"Install the Julia package","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\npkg\"add https://github.com/cjdoris/Python.jl\"","category":"page"},{"location":"getting-started/#Install-the-Python-package-(optional)","page":"Getting Started","title":"Install the Python package (optional)","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"This step is only required if you wish to call Julia from Python.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Currently the Python package is shipped with the source of the Julia package, and must be pip-installed manually. The following should work in most shells (including PowerShell):","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"pip install --upgrade $(julia -e \"using Python; print(Python.juliapypath)\")","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"Note that this is a very small \"bootstrap\" package whose sole job is to locate and load Julia; the main functionality is in the main Julia package. Hence it is not necessary to upgrage the Python package every time you upgrade the Julia one.","category":"page"},{"location":"getting-started/#Environment-variables","page":"Getting Started","title":"Environment variables","text":"","category":"section"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"If Julia and Python are in your PATH, then no further set-up is required. Otherwise, the following environment variables control how the package finds these.","category":"page"},{"location":"getting-started/","page":"Getting Started","title":"Getting Started","text":"PYTHONJL_EXE: Path to the Python executable. Or the special value CONDA which uses Python from the default conda environment, or CONDA:{env} to use the given environment.\nPYTHONJL_LIB: Path to the Python library. Normally this is inferred from the Python executable, but can be over-ridden.\nJULIAPY_EXE: Path to the Julia executable.\nJULIAPY_LIB: Path to the Julia library. Normally this is inferred from the Julia executable, but can be over-ridden.","category":"page"},{"location":"juliapy/#Julia-from-Python","page":"Julia from Python","title":"Julia from Python","text":"","category":"section"},{"location":"conversion/#Conversion-Rules","page":"Conversion Rules","title":"Conversion Rules","text":"","category":"section"},{"location":"conversion/#Julia-to-Python","page":"Conversion Rules","title":"Julia to Python","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"When a Julia object is converted to a Python one (e.g. by calling PyObject, by interpolating it into a @py command, or passing it as an argument to a Python function) the following rules are used by default.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The user can always explicitly choose a different conversion (e.g. by calling pylist or pydict).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"| From | To | | :–- | :- | | Any Python object type | itself | | nothing, missing | None | | Bool | bool | | Standard integer (IntXX, UIntXX, BigInt) | int | | Standard rational (Rational{T} where T is a standard integer) | fractions.Fraction | | Standard float (FloatXX) | float | | Standard complex (Complex{T} where T is a standard float) | complex | | Standard string/char (String and SubString{String}, Char) | str | | Tuple | tuple | | Standard integer range (AbstractRange{T} where T is a standard integer) | range | | Date, Time, DateTime (from Dates) | date, time, datetime (from datetime) | | Second, Millisecond, Microsecond, Nanosecond (from Dates) | timedelta (from datetime) | | Anything else | julia.AnyValue (read below) |","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"This conversion policy is defined/implemented by Python.C.PyObject_From.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The type julia.AnyValue holds a reference to a Julia object and provides access to Julia semantics about the object: it can be called, indexed, and so on.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"There are also subtypes, which have additional Pythonic semantics.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"| From | To | | :–- | :- | | Any | julia.AnyValue | | Integer, Rational, Real, Complex, Number | julia.IntegerValue, julia.RationalValue, julia.RealValue, julia.ComplexValue, julia.NumberValue. These fully implement the corresponding numeric interfaces from the numbers package. | | AbstractArray, AbstractVector | julia.ArrayValue, julia.VectorValue. These implement the Collection and Sequence interfaces from collections.abc. If the underlying array is strided and the element type is sufficiently compatible, the data is exposed through the buffer interface and numpy array interface. Always provides __array__, falling back to returning an array of objects, so conversion to numpy is always possible. | | AbstractDict, AbstractSet | julia.DictValue, julia.SetValue. These implement the Mapping and Set interfaces from collections.abc, and behave like dict and set. | | IO | julia.BufferedIOValue. Implements the BufferedIOBase interface from io. You can use pytextio to create a julia.TextIOValue instead, which implements TextIOBase. | | Module | julia.ModuleValue. This has one special method seval which takes a string of Julia code and evaluates it. | | Type | julia.TypeValue. This over-rides indexing behaviour so that indexing can be used to access the \"curly\" syntax for specifying parametric types. |","category":"page"},{"location":"conversion/#Python-to-Julia","page":"Conversion Rules","title":"Python to Julia","text":"","category":"section"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From Julia, one can convert Python objects to a desired type using pyconvert(T, x) for example, or @pyv `...`::T.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"From Python, when a value is passed to Julia, it is typically converted to a corresponding Julia value using pyconvert(Any, x).","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"The following table specifies the conversion rules in place. If the initial Python type matches the \"from\" column and the desired type T intersects with the \"To\" column, then that conversion is attempted. Conversions are tried in priority order, then in specificity order.","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"| From | To | How | | :–- | :- | :– | | Top priority (wrapped values). ||| | julia.AnyValue | Any | Extract the Julia value and try to convert. | | Very high priority (arrays). ||| | Objects satisfying the buffer or array interface | PyArray || | High priority (canonical conversions). ||| | ... todo ... ||| | Standard priority (other reasonable conversions). ||| | ... todo ... ||| | Low priority (fallback to PyObject).||| | Anything | PyObject || | Bottom priority (must be explicitly specified by excluding PyObject). ||| | Objects satisfying the buffer interface | PyBuffer || | Anything | PyRef ||","category":"page"},{"location":"conversion/","page":"Conversion Rules","title":"Conversion Rules","text":"Note that as with conversion from Julia to Python, by default only immutable objects are converted to a Julia equivalent, everything else is wrapped.","category":"page"},{"location":"#Python.jl","page":"Home","title":"Python.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bringing Python and Julia together in seamless harmony:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Call Python code from Julia and Julia code from Python via a symmetric interface.\nSimple syntax, so the Python code looks like Python and the Julia code looks like Julia.\nIntuitive and flexible conversions between Julia and Python: anything can be converted, you are in control.\nFast non-copying conversion of numeric arrays in either direction: modify Python arrays (e.g. bytes, array.array, numpy.ndarray) from Julia or Julia arrays from Python.\nHelpful wrappers: interpret Python sequences, dictionaries, arrays, dataframes and IO streams as their Julia couterparts, and vice versa.\nBeautiful stack-traces.\nWorks anywhere: tested on Windows, MacOS and Linux, 32- and 64-bit, Julia 1.0 upwards and Python 3.5 upwards.","category":"page"},{"location":"pythonjl/#Python-from-Julia","page":"Python from Julia","title":"Python from Julia","text":"","category":"section"},{"location":"pythonjl/#Execute-Python-code","page":"Python from Julia","title":"Execute Python code","text":"","category":"section"},{"location":"pythonjl/#PyObjects","page":"Python from Julia","title":"PyObjects","text":"","category":"section"},{"location":"pythonjl/#Wrapper-types","page":"Python from Julia","title":"Wrapper types","text":"","category":"section"},{"location":"pythonjl/","page":"Python from Julia","title":"Python from Julia","text":"PyList\nPySet\nPyDict\nPyIterable\nPyArray\nPyBuffer\nPyIO\nPyPandasDataFrame","category":"page"},{"location":"pythonjl/#Python.PyList","page":"Python from Julia","title":"Python.PyList","text":"PyList{T=PyObject}([o])\n\nWrap the Python list o (or anything satisfying the sequence interface) as a Julia vector with elements of type T.\n\nIf o is not given, an empty list is created.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PySet","page":"Python from Julia","title":"Python.PySet","text":"PySet{T=PyObject}([o])\n\nWrap the Python set o (or anything satisfying the set interface) as a Julia set with elements of type T.\n\nIf o is not given, an empty set is created.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyDict","page":"Python from Julia","title":"Python.PyDict","text":"PyDict{K=PyObject, V=PyObject}([o])\n\nWrap the Python dictionary o (or anything satisfying the mapping interface) as a Julia dictionary with keys of type K and values of type V.\n\nIf o is not given, an empty dict is created.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyIterable","page":"Python from Julia","title":"Python.PyIterable","text":"PyIterable{T=PyObject}(o)\n\nWrap the Python object o into a Julia object which iterates values of type T.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyArray","page":"Python from Julia","title":"Python.PyArray","text":"PyArray{T,N,R,M,L}(o)\n\nInterpret the Python array o as a Julia array.\n\nThe input may be anything supporting the buffer protocol or the numpy array interface. This includes bytes, bytearray, array.array, numpy.ndarray, pandas.Series.\n\nAll type parameters are optional:\n\nT is the (Julia) element type.\nN is the number of dimensions.\nR is the type of elements of the underlying buffer (which may be different from T to allow some basic conversion).\nM is true if the array is mutable.\nL is true if the array supports fast linear indexing.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyBuffer","page":"Python from Julia","title":"Python.PyBuffer","text":"PyBuffer(o, [flags=C.PyBUF_FULL_RO])\n\nA reference to the underlying buffer of o, if it satisfies the buffer protocol.\n\nHas the following properties:\n\nbuf: Pointer to the data.\nobj: The exporting object (usually o).\nlen: The length of the buffer in bytes.\nreadonly: True if the buffer is immutable.\nitemsize: The size of each element.\nformat: The struct-syntax format of the element type.\nndim: The number of dimensions.\nshape: The length of the buffer in each dimension.\nstrides: The strides (in bytes) of the buffer in each dimension.\nsuboffsets: For indirect arrays. See the buffer protocol documentation.\nisccontiguous: True if the buffer is C-contiguous (e.g. numpy arrays).\nisfcontiguous: True if the buffer is Fortran-contiguous (e.g. Julia arrays).\neltype: The element type.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyIO","page":"Python from Julia","title":"Python.PyIO","text":"PyIO(o; own=false, text=missing, buflen=4096)\n\nWrap the Python byte-based IO stream o as a Julia IO stream.\n\nWhen this goes out of scope and is finalized, it is automatically flushed. If own=true then it is also closed.\n\nIf text=false then o must be a binary stream and arbitrary binary I/O is possible. If text=true then o must be a text stream and only UTF-8 must be written (i.e. use print not write). If text is not specified then it is chosen automatically. If o is a text stream and you really need a binary stream, then often PyIO(o.buffer) will work.\n\nFor efficiency, reads and writes are buffered before being sent to o. The size of the buffer is buflen.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Python.PyPandasDataFrame","page":"Python from Julia","title":"Python.PyPandasDataFrame","text":"PyPandasDataFrame(o; indexname=:index, columntypes=(), copy=false)\n\nWrap the Pandas dataframe o as a Julia table.\n\nThis object satisfies the Tables.jl and TableTraits.jl interfaces.\n\n:indexname is the name of the index column when converting this to a table, and may be nothing to exclude the index.\n:columntypes is an iterable of columnname=>type or [columnnames...]=>type pairs, used when converting to a table.\n:copy is true to copy columns on conversion.\n\n\n\n\n\n","category":"type"},{"location":"pythonjl/#Conversion-to-Python","page":"Python from Julia","title":"Conversion to Python","text":"","category":"section"},{"location":"pythonjl/#Conversion-from-Python","page":"Python from Julia","title":"Conversion from Python","text":"","category":"section"}]
}
