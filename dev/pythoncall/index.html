<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Julia module PythonCall · PythonCall &amp; JuliaCall</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PythonCall &amp; JuliaCall logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PythonCall &amp; JuliaCall</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>The Julia module PythonCall</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Getting-started"><span>Getting started</span></a></li><li><a class="tocitem" href="#Conversion-between-Julia-and-Python"><span>Conversion between Julia and Python</span></a></li><li><a class="tocitem" href="#Wrapper-types"><span>Wrapper types</span></a></li><li><a class="tocitem" href="#python-deps"><span>Installing Python packages</span></a></li><li><a class="tocitem" href="#Writing-packages-which-depend-on-PythonCall"><span>Writing packages which depend on PythonCall</span></a></li><li><a class="tocitem" href="#Low-level-API"><span>Low-level API</span></a></li></ul></li><li><a class="tocitem" href="../juliacall/">The Python module JuliaCall</a></li><li><a class="tocitem" href="../conversion-to-python/">Conversion to Python</a></li><li><a class="tocitem" href="../conversion-to-julia/">Conversion to Julia</a></li><li><a class="tocitem" href="../compat/">Compatibility Tools</a></li><li><a class="tocitem" href="../pythoncall-reference/">PythonCall API Reference</a></li><li><a class="tocitem" href="../juliacall-reference/">JuliaCall API Reference</a></li><li><a class="tocitem" href="../pycall/">Coming from <em>PyCall</em>?</a></li><li><a class="tocitem" href="../releasenotes/">Release Notes</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Julia module PythonCall</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Julia module PythonCall</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cjdoris/PythonCall.jl/blob/master/docs/src/pythoncall.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Julia-module-PythonCall"><a class="docs-heading-anchor" href="#The-Julia-module-PythonCall">The Julia module PythonCall</a><a id="The-Julia-module-PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#The-Julia-module-PythonCall" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This package is in the general registry, so to install just type <code>]</code> in the Julia REPL and run:</p><pre><code class="language-julia-repl hljs">pkg&gt; add PythonCall</code></pre><h2 id="Getting-started"><a class="docs-heading-anchor" href="#Getting-started">Getting started</a><a id="Getting-started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-started" title="Permalink"></a></h2><p>Import the module with:</p><pre><code class="language-julia-repl hljs">julia&gt; using PythonCall</code></pre><p>By default this will initialize a conda environment in your Julia environment, install Python into it, load the corresponding Python library and initialize an interpreter.</p><p>Now you can interact with Python as follows:</p><pre><code class="language-julia-repl hljs">julia&gt; re = pyimport(&quot;re&quot;)
Python module: &lt;module &#39;re&#39; from &#39;[...]/lib/re.py&#39;&gt;

julia&gt; words = re.findall(&quot;[a-zA-Z]+&quot;, &quot;PythonCall.jl is very useful!&quot;)
Python list: [&#39;PythonCall&#39;, &#39;jl&#39;, &#39;is&#39;, &#39;very&#39;, &#39;useful&#39;]

julia&gt; sentence = Py(&quot; &quot;).join(words)
Python str: &#39;PythonCall jl is very useful&#39;

julia&gt; pyconvert(String, sentence)
&quot;PythonCall jl is very useful&quot;</code></pre><p>In this example:</p><ul><li>We used <a href="../pythoncall-reference/#PythonCall.pyimport"><code>pyimport</code></a> to import the <code>re</code> module.</li><li>We called its <code>findall</code> function on a pair of strings, which were automatically converted to Python strings (see <a href="../conversion-to-python/#jl2py">Conversion to Python</a>).</li><li>We called <a href="../pythoncall-reference/#PythonCall.Py"><code>Py</code></a> to explicitly convert a string to a Python string, so that we could call its <code>join</code> method. All Python objects are of type <code>Py</code>.</li><li>We called <a href="../pythoncall-reference/#PythonCall.pyconvert"><code>pyconvert</code></a> to convert the Python string <code>sentence</code> to a Julia string (see <a href="../conversion-to-julia/#py2jl">Conversion to Julia</a>).</li></ul><p>The values <code>re</code>, <code>words</code> and <code>sentence</code> in the example are all Python objects, which have type <a href="../pythoncall-reference/#PythonCall.Py"><code>Py</code></a> in Julia. As we have seen, these objects support attribute access (e.g. <code>re.findall</code>) and function calls (e.g. <code>join(words)</code>). They also support indexing, comparison and arithmetic:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pylist([3, 4, 5])
Python list: [3, 4, 5]

julia&gt; x[2] == 5
Python bool: True

julia&gt; x[pyslice(0,2)] + pylist([1,2])
Python list: [3, 4, 1, 2]</code></pre><p>We have just seen the functions <a href="../pythoncall-reference/#PythonCall.pylist"><code>pylist</code></a> (for constructing a Python list) and <a href="../pythoncall-reference/#PythonCall.pyslice"><code>pyslice</code></a> (for constructing a Python slice). There are many such functions, mirroring most of the Python builtin functions and types. The <a href="@ref PythonCall API Reference">API Reference</a> documents them all.</p><p>Most of these functions are essentially Python builtins with a <code>py</code> prefix. For example <code>pyint(x)</code> converts <code>x</code> to a Python <code>int</code> and is equivalent to <code>int(x)</code> in Python when <code>x</code> is a Python object.</p><p>Notable exceptions are:</p><ul><li><a href="../pythoncall-reference/#PythonCall.pyconvert"><code>pyconvert</code></a> to convert a Python object to a Julia object.</li><li><a href="../pythoncall-reference/#PythonCall.pyimport"><code>pyimport</code></a> to import a Python module.</li><li><a href="../pythoncall-reference/#PythonCall.pyjl"><code>pyjl</code></a> to directly wrap a Julia object as a Python object.</li><li><a href="../pythoncall-reference/#PythonCall.pywith"><code>pywith</code></a> to emulate the Python <code>with</code> statement.</li></ul><p>To access the Python builtins directly, you can access the fields of <a href="../pythoncall-reference/#PythonCall.pybuiltins"><code>pybuiltins</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; pybuiltins.None
Python None

julia&gt; pybuiltins.True
Python bool: True

julia&gt; pybuiltins.ValueError(&quot;some error&quot;)
Python ValueError: ValueError(&#39;some error&#39;)</code></pre><p>With the functions introduced so far, you have access to the vast majority of Python&#39;s functionality.</p><h2 id="Conversion-between-Julia-and-Python"><a class="docs-heading-anchor" href="#Conversion-between-Julia-and-Python">Conversion between Julia and Python</a><a id="Conversion-between-Julia-and-Python-1"></a><a class="docs-heading-anchor-permalink" href="#Conversion-between-Julia-and-Python" title="Permalink"></a></h2><p>A Julia object can be converted to a Python one either explicitly (such as <code>Py(x)</code>) or implicitly (such as the arguments when calling a Python function). Either way, it follows the default conversion rules <a href="../conversion-to-python/#jl2py">here</a>.</p><p>Most operations involving Python objects will return a <code>Py</code> and are not automatically converted to another Julia type. Instead, you can explicitly convert using <a href="../pythoncall-reference/#PythonCall.pyconvert"><code>pyconvert</code></a>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pylist([3.4, 5.6])
Python list: [3.4, 5.6]

julia&gt; pyconvert(Vector, x)
2-element Vector{Float64}:
 3.4
 5.6

julia&gt; pyconvert(Vector{Float32}, x)
2-element Vector{Float32}:
 3.4
 5.6

julia&gt; pyconvert(Any, x)
2-element PyList{Py}:
 3.4
 5.6</code></pre><p>In the above example, we converted a Python list to a Julia vector in three ways.</p><ul><li><code>pyconvert(Vector, x)</code> returned a <code>Vector{Float64}</code> since all the list items are floats.</li><li><code>pyconvert(Vector{Float32}, x)</code> specified the element type, so the floats were converted to <code>Float32</code>.</li><li><code>pyconvert(Any, x)</code> returned a <code>PyList{Py}</code> which is a no-copy wrapper around the original list <code>x</code>, viewing it as a <code>AbstractVector{Py}</code>. Since it is a wrapper, mutating it mutates <code>x</code> and vice-versa.</li></ul><p>See <a href="../conversion-to-julia/#py2jl">here</a> for the rules regarding how <code>pyconvert(T, x)</code> works. If <code>x</code> is an immutable scalar type (such as an <code>int</code> or <code>str</code>) then <code>pyconvert(Any, x)</code> may return the corresponding Julia object (such as an <code>Integer</code> or <code>String</code>). Otherwise it will typically return either a <a href="@ref Wrapper types">wrapper type</a> (such as <code>PyList{Py}</code> in the above example) or will fall back to returning a <a href="../pythoncall-reference/#PythonCall.Py"><code>Py</code></a>.</p><h2 id="Wrapper-types"><a class="docs-heading-anchor" href="#Wrapper-types">Wrapper types</a><a id="Wrapper-types-1"></a><a class="docs-heading-anchor-permalink" href="#Wrapper-types" title="Permalink"></a></h2><p>A wrapper is a type which wraps a Python object but provides it with the semantics of some other Julia type.</p><p>Since it is merely wrapping a Python object, if you mutate the wrapper you also mutate the wrapped object, and vice versa.</p><p>See <a href="../pythoncall-reference/#python-wrappers">here</a> for details of all the wrapper types provided by PythonCall.</p><p>We have already seen <a href="../pythoncall-reference/#PythonCall.PyList"><code>PyList</code></a>. It wraps any Python sequence (such as a list) as a Julia vector:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pylist([3,4,5])
Python list: [3, 4, 5]

julia&gt; y = PyList{Union{Int,Nothing}}(x)
3-element PyList{Union{Nothing, Int64}}:
 3
 4
 5

julia&gt; push!(y, nothing)
4-element PyList{Union{Nothing, Int64}}:
 3
 4
 5
  nothing

julia&gt; append!(y, 1:2)
6-element PyList{Union{Nothing, Int64}}:
 3
 4
 5
  nothing
 1
 2

julia&gt; x
Python list: [3, 4, 5, None, 1, 2]</code></pre><p>There are wrappers for other container types, such as <a href="../pythoncall-reference/#PythonCall.PyDict"><code>PyDict</code></a> and <a href="../pythoncall-reference/#PythonCall.PySet"><code>PySet</code></a>.</p><p>The wrapper <a href="../pythoncall-reference/#PythonCall.PyArray"><code>PyArray</code></a> provides a Julia array view of any Python array, i.e. anything satisfying either the buffer protocol or the numpy array interface. This includes things like <code>bytes</code>, <code>bytearray</code>, <code>array.array</code> and <code>numpy.ndarray</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pyimport(&quot;array&quot;).array(&quot;i&quot;, [3, 4, 5])
Python array: array(&#39;i&#39;, [3, 4, 5])

julia&gt; y = PyArray(x)
3-element PyArray{Int32, 1, true, true, Int32}:
 3
 4
 5

julia&gt; sum(y)
12

julia&gt; y[1] = 0
0

julia&gt; x
Python array: array(&#39;i&#39;, [0, 4, 5])</code></pre><p>It directly wraps the underlying data buffer, so array operations such as indexing are about as fast as for an ordinary <code>Array</code>.</p><p>The <a href="../pythoncall-reference/#PythonCall.PyIO"><code>PyIO</code></a> wrapper type views a Python file object as a Julia IO object:</p><pre><code class="language-julia-repl hljs">julia&gt; x = pyimport(&quot;io&quot;).StringIO()
Python StringIO: &lt;_io.StringIO object at 0x000000006579BC70&gt;

julia&gt; y = PyIO(x)
PyIO(&lt;py _io.StringIO object at 0x000000006579BC70&gt;, false, true, false, 4096, UInt8[], 4096, UInt8[])

julia&gt; println(y, &quot;Hello, world!&quot;)

julia&gt; flush(y)

julia&gt; x.seek(0)
Python int: 0

julia&gt; x.read()
Python str: &#39;Hello, world!\n&#39;</code></pre><h2 id="python-deps"><a class="docs-heading-anchor" href="#python-deps">Installing Python packages</a><a id="python-deps-1"></a><a class="docs-heading-anchor-permalink" href="#python-deps" title="Permalink"></a></h2><p>PythonCall uses <a href="https://github.com/cjdoris/CondaPkg.jl">CondaPkg.jl</a> to manage its dependencies. Namely, CondaPkg will automatically install Python and any packages required into a Conda environment specific to your current project.</p><p>If your project requires any Python packages, add a <code>CondaPkg.toml</code> file to your project specifying what you need. Alternatively use <code>CondaPkg.add()</code> to add dependencies from the REPL.</p><h2 id="Writing-packages-which-depend-on-PythonCall"><a class="docs-heading-anchor" href="#Writing-packages-which-depend-on-PythonCall">Writing packages which depend on PythonCall</a><a id="Writing-packages-which-depend-on-PythonCall-1"></a><a class="docs-heading-anchor-permalink" href="#Writing-packages-which-depend-on-PythonCall" title="Permalink"></a></h2><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>See <a href="https://github.com/cjdoris/Faiss.jl">https://github.com/cjdoris/Faiss.jl</a> for an example package which wraps the Python FAISS package.</p><h3 id="Precompilation"><a class="docs-heading-anchor" href="#Precompilation">Precompilation</a><a id="Precompilation-1"></a><a class="docs-heading-anchor-permalink" href="#Precompilation" title="Permalink"></a></h3><p>You may not interact with Python during module precompilation. Therefore, instead of</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  const foo = pyimport(&quot;foo&quot;)
  bar() = foo.bar() # will crash when called
end</code></pre><p>you must do</p><pre><code class="language-julia hljs">module MyModule
  using PythonCall
  const foo = PythonCall.pynew() # initially NULL
  function __init__()
    PythonCall.pycopy!(foo, pyimport(&quot;foo&quot;))
  end
  bar() = foo.bar() # now ok
end</code></pre><h3 id="Dependencies"><a class="docs-heading-anchor" href="#Dependencies">Dependencies</a><a id="Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Dependencies" title="Permalink"></a></h3><p>If your package depends on some Python packages, you must write a <code>CondaPkg.toml</code> file. See <a href="#python-deps">Installing Python packages</a>.</p><h2 id="Low-level-API"><a class="docs-heading-anchor" href="#Low-level-API">Low-level API</a><a id="Low-level-API-1"></a><a class="docs-heading-anchor-permalink" href="#Low-level-API" title="Permalink"></a></h2><p>The functions here are not exported. They are mostly unsafe in the sense that you can crash Julia by using them incorrectly.</p><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pynew" href="#PythonCall.pynew"><code>PythonCall.pynew</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pynew([ptr])</code></pre><p>A new <code>Py</code> representing the Python object at <code>ptr</code> (NULL by default).</p><p>If <code>ptr</code> is given and non-NULL, this function steals a reference to the Python object it points at, i.e. the new <code>Py</code> object owns a reference.</p><p>Note that NULL Python objects are not safe in the sense that most API functions will probably crash your Julia session if you pass a NULL argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/0eb489de2464ec530c058ab746bc4444689a28d2/src/Py.jl#L66-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pyisnull" href="#PythonCall.pyisnull"><code>PythonCall.pyisnull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pyisnull(x)</code></pre><p>True if the Python object <code>x</code> is NULL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/0eb489de2464ec530c058ab746bc4444689a28d2/src/Py.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pycopy!" href="#PythonCall.pycopy!"><code>PythonCall.pycopy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pycopy!(dst::Py, src)</code></pre><p>Copy the Python object <code>src</code> into <code>dst</code>, so that they both represent the same object.</p><p>This function exists to support module-level constant Python objects. It is illegal to call most PythonCall API functions at the top level of a module (i.e. before <code>__init__()</code> has run) so you cannot do <code>const x = pything()</code> at the top level. Instead do <code>const x = pynew()</code> at the top level then <code>pycopy!(x, pything())</code> inside <code>__init__()</code>.</p><p>Assumes <code>dst</code> is NULL, otherwise a memory leak will occur.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/0eb489de2464ec530c058ab746bc4444689a28d2/src/Py.jl#L88-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.getptr" href="#PythonCall.getptr"><code>PythonCall.getptr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getptr(x)</code></pre><p>Get the underlying pointer from the Python object <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/0eb489de2464ec530c058ab746bc4444689a28d2/src/Py.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.pydel!" href="#PythonCall.pydel!"><code>PythonCall.pydel!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pydel!(x::Py)</code></pre><p>Delete the Python object <code>x</code>.</p><p>DANGER! Use this function ONLY IF the Julia object <code>x</code> could have been garbage-collected anyway, i.e. was about to become unreachable. This means you MUST KNOW that no other part of the program has the Julia object <code>x</code>.</p><p>This decrements the reference count, sets the pointer to NULL and appends <code>x</code> to a cache of unused objects (<code>PYNULL_CACHE</code>).</p><p>This is an optimization to avoid excessive allocation and deallocation in Julia, which can be a significant source of slow-down in code which uses a lot of Python objects. It allows <code>pynew()</code> to pop an item from <code>PYNULL_CACHE</code> instead of allocating one, and avoids calling the relatively slow finalizer on <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/0eb489de2464ec530c058ab746bc4444689a28d2/src/Py.jl#L102-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PythonCall.unsafe_pynext" href="#PythonCall.unsafe_pynext"><code>PythonCall.unsafe_pynext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_pynext(x)</code></pre><p>Return the next item in the iterator <code>x</code>. When there are no more items, return NULL.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cjdoris/PythonCall.jl/blob/0eb489de2464ec530c058ab746bc4444689a28d2/src/abstract/iter.jl#L17-L21">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../juliacall/">The Python module JuliaCall »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.15 on <span class="colophon-date" title="Friday 18 March 2022 10:50">Friday 18 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
